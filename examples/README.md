## Example datasets

These example GFA files have been generated from <a href="https://github.com/maickrau/MBG">MBG</a> on readsets generated by the Darwin Tree of Life project.

I'll take one example, the Costard Apple.

We will look at some stats first:

```bash
gfatk stats drMalDome11_5k.gfa
```

This is the output, containing some simple statistics about the graph. If there was more than one subgraph in the GFA, these would be separated out.

```
Subgraph 1:
        Number of nodes/segments: 3
        Number of edges/links: 8

        Segment ID's:
        4, 5, 6

        Total sequence length:  400966
        Total sequence overlap length:  55848
        Sequence length minus overlaps: 345118
        GC content of total sequence:   0.45705
        Average coverage of total segments:     275.845
Total number of subgraphs: 1
```

This looks mitochondria-ey, with a sequence length 300-400Kb and GC content ~45%. Let's plot it!

```bash
# install dot -> `conda install -c anaconda graphviz`
# graphviz is a *very* cool bit of software.
gfatk dot drMalDome5_11.gfa | dot -Tsvg > drMalDome5_11.svg
```

<p align="center">
  <img src="./drMalDome11_5k.svg" />
</p>

Now that we're confident it's a mito, let's linearise the GFA. By default this is done by finding the longest path through the graph, visiting each node only once. It's like a hamiltonian path but with some constraints (orientation of segments matters).

```bash
# I am piping the output (which would be a fasta) into the void
# because I'm only interested in the stderr output
gfatk linear ./examples/drMalDome11_5k.gfa > /dev/null
```

MBG kindly outputs the coverage of the edges between the graph segments (see the graph above) for us, so we can see which paths have more coverage, and take these into account when linearising (in this case the edge coverages were not that informative). We can see the output generated a path of length three (phew), which is how many segments there were in the graph.

```
[+]     Highest cumulative coverage path = 426
[+]     Chosen path through graph: - 6 -> - 5 -> + 4
```

We can include the `-i` flag, to force `gfatk` to take into account the coverage of the *segments* (in contrast to the edge coverages above). In this case, looking at the graph above we can see that segment 5 occurs at about double the coverage of the other segments:

```bash
# pass the `-i` flag
gfatk linear -i ./examples/drMalDome11_5k.gfa > /dev/null
```

Shows this:

```
[+]     Highest cumulative coverage path = 661
[+]     Chosen path through graph: - 5 -> + 4 -> + 5 -> + 6
```

We've included more edges, so the total edge coverage goes up, and we have added segment 5 twice. A note here that if there is a large variance in coverage between nodes, the number of possible paths to explore in graph space explodes. In this case, you'll get a stack overflow and `gfatk` will be broken.